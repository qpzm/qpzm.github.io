<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		
		<meta name="generator" content="Hugo 0.55.4" />
		<title>[Book] Metaprogramming in Ruby 2 &middot; Hyunmin Lee</title>
		<link rel="shortcut icon" href="https://qpzm.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://qpzm.github.io/css/style.css">
		<link rel="stylesheet" href="https://qpzm.github.io/css/highlight.css">

		
		<link rel="stylesheet" href="https://qpzm.github.io/css/font-awesome.min.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://qpzm.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://qpzm.github.io/posts'>Archive</a>
	<a href='https://qpzm.github.io/tags'>Tags</a>
	<a href='https://qpzm.github.io/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        [Book] Metaprogramming in Ruby 2
                    </h1>
                    <h2 class="headline">
                    Sep 9, 2019 12:00
                    · 1867 words
                    · 9 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://qpzm.github.io/tags/ruby">Ruby</a>
                          
                              <a href="https://qpzm.github.io/tags/metaprogramming">Metaprogramming</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>Paolo Perrotta의 <a href="http://shop.oreilly.com/product/9781941222126.do">Metaprogramming Ruby 2</a> 를 읽으면서 메모한 내용입니다. 퀴즈 솔루션은 <a href="https://github.com/qpzm/metaprogramming_ruby">https://github.com/qpzm/metaprogramming_ruby</a> 에 있습니다.</p>

<h2 id="ch2-the-object-model">Ch2. The Object Model</h2>

<h3 id="instance-variable은-할당할-때-생긴다">instance variable은 할당할 때 생긴다</h3>

<blockquote>
<p>Instance variables just spring into existence when you assign them a value, so you can have objects of the same class that carry different instance variables.</p>
</blockquote>

<h3 id="instance-methods">instance methods</h3>

<p>An object’s methods live in the object’s class.</p>

<h3 id="class-vs-module">class vs module</h3>

<blockquote>
<p>a class is a module with three additional instance methods (new, allocate, and superclass)</p>
</blockquote>

<h3 id="a-class-is-just-an-object">A class is just an object</h3>

<p><img src="https://user-images.githubusercontent.com/18223805/62420415-c9fe9880-b6cc-11e9-9d17-8f5fdea70df1.png" alt="A class is just an object" /></p>

<h3 id="wrap-up">Wrap-up</h3>

<blockquote>
<p>What’s a class? It’s an object (an instance of Class), plus a list of instance methods and a link to a superclass.</p>
</blockquote>

<h3 id="question">Question</h3>

<p>모든 클래스의 클래스가 Class면 <code>Class</code>라는 클래스는 재귀적으로 정의되나?</p>

<pre><code class="language-ruby">class Class
end
</code></pre>

<h3 id="ruby-class에-대한-보충-설명">Ruby class에 대한 보충 설명</h3>

<p><code>intialize</code> is not a constructor!
&gt; When Name.<strong>new</strong> is called to create a new object, the <strong>new</strong> class method in <strong>Class</strong> is run by default, which in turn invokes <strong>allocate</strong> to allocate memory for the object, before finally calling the new object’s <strong>initialize</strong> method.</p>

<h3 id="what-happens-when-you-call-a-method">What happens when you call a method?</h3>

<blockquote>
<p>When you call a method, Ruby does two things:
1. It finds the method. This is a process called <em>method lookup</em>.
2. It executes the method. To do that, Ruby needs something called self.</p>
</blockquote>

<h3 id="method-lookup">Method lookup</h3>

<ul>
<li>receiver</li>
<li>ancestors chain
<code>ruby
MySubclass.ancestors # =&gt; [MySubclass, MyClass, Object, Kernel, BasicObject]
</code></li>
</ul>

<h4 id="modules-and-lookup">Modules and lookup</h4>

<p>include는 ancestors chain에서 해당 클래스 위에, prepend는 밑에 붙임. 따라서 prepend는 현재 클래스보다 더 우선. 아래 코드의 ancestors chain을 그려보자.</p>

<pre><code class="language-ruby">class C1; include M1; end
class D1 &lt; C1; end
class C2; prepend M2; end
class D2 &lt; C2; end

class Object &lt; BasicObject
  include Kernel
end
</code></pre>

<!--![Method lookup chain]("https://user-images.githubusercontent.com/18223805/62420541-b94f2200-b6ce-11e9-8b77-c8a965825ae3.png") -->

<h4 id="multiple-inclusion">Multiple inclusion</h4>

<blockquote>
<p>if that module is already in the chain, Ruby silently ignores the second inclusion.</p>
</blockquote>

<p>M2가 M1을 include하지만 이미 M3에서 <code>prepend M1</code>을 선언했기 때문에 무시된다.</p>

<pre><code class="language-ruby">module M1; end
module M2 include M1
end
module M3 prepend M1 include M2
end
M3.ancestors # =&gt; [M1, M3, M2]
</code></pre>

<h3 id="the-kernel">The Kernel</h3>

<pre><code class="language-ruby">Kernel.private_instance_methods.grep(/^pr/) # =&gt; [:printf, :print, :proc]
</code></pre>

<blockquote>
<p>Every line of Ruby is always executed inside an object, so you can call the instance methods in Kernel from anywhere. This gives you the illusion that print is a language keyword, when it’s actually a method.</p>
</blockquote>

<h3 id="what-private-really-means">What private really means</h3>

<blockquote>
<p>Private methods are governed by a single simple rule: you cannot call a private method with an explicit receiver.</p>
</blockquote>

<h3 id="methods-in-example-code">Methods in example code</h3>

<h4 id="w">\w</h4>

<blockquote>
<p>밑줄 문자를 포함한 영숫자 문자에 대응됩니다. [A-Za-z0-9_] 와 동일합니다.</p>
</blockquote>

<h4 id="enumerable-grep">Enumerable#grep</h4>

<pre><code class="language-ruby">[].methods.grep /^re/ # =&gt; [:reverse_each, :reverse, ..., :replace, ...]
</code></pre>

<h4 id="array-replace">Array#replace</h4>

<pre><code class="language-ruby">a = [ “a”, “b”, “c”, “d”, “e” ]
a.replace([ “x”, “y”, “z” ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
</code></pre>

<h2 id="ch3-methods">Ch3. Methods</h2>

<pre><code class="language-ruby">data_source.methods.grep(/^get_(.*)_info$/) { Computer.define_component $1 }
</code></pre>

<p><code>method_missing</code> and <code>block_given?</code></p>

<pre><code class="language-ruby">class Lawyer   def method_missing(method, *args)      puts &quot;You called: #{method}(#{args.join(', ')})&quot;      puts &quot;(You also passed it a block)&quot; if block_given? end  end
</code></pre>

<p><code>String#capitalize</code>  : <code>String#upcase</code> 와 구별
&gt; Returns a copy of <em>str</em> with the first character converted to uppercase and the remainder to lowercase.</p>

<h2 id="ch4-blocks">Ch4. Blocks</h2>

<p><code>Kernel#block_given?</code> 으로 메소드에 블록이 주어졌는 지 알 수 있다.</p>

<h3 id="quiz-using을-풀-때-유용한-정보">Quiz using을 풀 때 유용한 정보</h3>

<h4 id="kernel-module">Kernel module</h4>

<blockquote>
<p>The Kernel module is included by class  <a href="file:///Users/hm/Library/Application%20Support/Dash/Versioned%20DocSets/Ruby%202%20-%20DHDocsetDownloader/2-5-3/Ruby.docset/Contents/Resources/Documents/Object.html">Object</a> , so its methods are available in every Ruby object.
 <a href="http://ruby-doc.org/core-2.5.3/Kernel.html">Module: Kernel (Ruby 2.5.3)</a></p>
</blockquote>

<h4 id="the-main-object">The main object</h4>

<blockquote>
<p>When a new program starts, Ruby automatically creates the main object which is an instance of the Object class. main is the top-level context of any program. This is probably a nod to the C language (as the main() function is the entry point of any C program and that Matz loves C)</p>

<pre><code class="language-ruby">irb&gt; self
 =&gt; main
irb&gt; self.class
 =&gt; Object
</code></pre>

<p><a href="https://medium.com/rubycademy/ruby-object-model-part-1-4d06fa486bec">https://medium.com/rubycademy/ruby-object-model-part-1-4d06fa486bec</a></p>
</blockquote>

<h4 id="ruby-exception-handling">Ruby exception handling</h4>

<pre><code class="language-ruby">begin
  # something which might raise an exception
rescue SomeExceptionClass =&gt; some_variable
  # code that deals with some exception
rescue SomeOtherException =&gt; some_other_variable
  # code that deals with some other exception
else
  # code that runs only if *no* exception was raised
ensure
  # ensure that this code always runs, no matter what
  # does not change the final value of the block
end
</code></pre>

<h3 id="closure">Closure</h3>

<p>When you create the block, you capture the local bindings, such as x.</p>

<pre><code class="language-ruby">def my_method
x = &quot;Goodbye&quot; yield (&quot;cruel&quot;)
end
x = &quot;Hello&quot;
my_method {|y| &quot;#{x},#{y} world&quot;} # =&gt; &quot;Hello, cruel world&quot;
</code></pre>

<p>block 안에서 만든 변수는 블록이 끝나면 사라짐. 이 두 가지 특징으로 인해 블록은 클로져다. For the rest of us, this means a block captures the local bindings and carries them along with it.</p>

<h3 id="operator-turns-a-proc-to-a-block">&amp; operator turns a proc to a block</h3>

<pre><code class="language-ruby">def my_method(greeting)
  &quot;#{greeting}, #{yield}!&quot;
end
my_proc = proc {&quot;Bill&quot;} my_method(&quot;Hello&quot;, &amp;my_proc)
</code></pre>

<h3 id="scope">Scope</h3>

<p><code>Kernel#local_variables</code> 로 지역 변수를 확인할 수 있다.</p>

<p>ruby는 scope gate를 지날 때 마다 새 스코프로 교체된다.</p>

<h4 id="scope-gates">Scope Gates</h4>

<p>There are exactly three places where a program leaves the previous scope behind and opens a new one:
* Class definitions
* Module definitions
* Methods
클래스나 모듈 스코프에 있는 코드는 바로 실행되는데 메소드 스코프에 있는 코드는 호출이 될 때야 비로서 실행된다.</p>

<p>Top level main object의 instance variable을 전역변수처럼 사용하는 예. <code>@var</code>은 main이 self인 스코프에서 접근 가능하다.</p>

<pre><code class="language-ruby">@var = &quot;The top-level @var&quot;
def my_method
  @var
end
</code></pre>

<h4 id="passing-scope-gates">Passing scope gates</h4>

<blockquote>
<p>Ruby coders refer to it simply as “flattening the scope,” meaning that the two scopes share variables as if the scopes were squeezed together.</p>
</blockquote>

<pre><code class="language-ruby">my_var = &quot;Success&quot;
MyClass = Class.new do
  &quot;#{my_var} in the class definition&quot;
  define_method :my_method do
    &quot;#{my_var} in the method&quot;
  end
end
</code></pre>

<h4 id="sharing-the-scope-without-global-var">Sharing the scope without global var</h4>

<pre><code class="language-ruby">def define_methods
  shared = 0
  Kernel.send :define_method, :counter do
    shared
  end
  Kernel.send :define_method, :inc do
    |x| shared += x
  end
end

define_methods
counter # =&gt; 0 inc(4) counter # =&gt; 4
</code></pre>

<h3 id="instance-eval">instance_eval()</h3>

<pre><code class="language-ruby">class MyClass
  def initialize
    @v = 1
  end
end

obj = MyClass.new
obj.instance_eval do   self # =&gt; #&lt;MyClass:0x3340dc @v=1&gt; @v # =&gt; 1
end
</code></pre>

<blockquote>
<p>The block is evaluated with the receiver as self, so it can access the receiver’s private methods and instance variables, such as @v. Even if instance_eval changes self, the block that you pass to instance_eval can still see the bindings from the place where it’s defined, like any other block:</p>

<pre><code class="language-ruby">v=2 obj.instance_eval { @v = v }
obj.instance_eval { @v } # =&gt; 2
</code></pre>
</blockquote>

<p>자세한 내용은 <code>BasicObject#instace_eval</code> 문서를 참조하자.</p>

<h3 id="instance-exec-은-parameter를-넘겨줄-수-있음"><code>instance_exec</code> 은 parameter를 넘겨줄 수 있음.</h3>

<p><code>instance_eval</code> 로 해결할 수 없는 경우</p>

<pre><code class="language-ruby">class C
  def initialize
    @x = 1
  end
end

class D
  def twisted_method
    @y = 2
    C.new.instance_eval { &quot;@x: #{@x}, @y: #{@y}&quot; }
  end
end
D.new.twisted_method # =&gt; &quot;@x: 1, @y: &quot;
</code></pre>

<p><code>instance_eval</code> 은 self를 바꾸기 때문에 block이라 하더라도 이전 scope의 instance variable에는 접근할 수 없다. 이 때 <code>instance_exec</code>을 사용하면 parameter를 넘겨주는 방법으로 해결할 수 있다.</p>

<pre><code class="language-ruby">class D
  def twisted_method
    @y = 2
    C.new.instance_exec(@y) {|y| &quot;@x: #{@x}, @y: #{y}&quot; }
  end
end
D.new.twisted_method # =&gt; &quot;@x: 1, @y: 2&quot;
</code></pre>

<h3 id="proc-vs-lambda의-두-가지-차이">Proc vs Lambda의 두 가지 차이</h3>

<h4 id="arity">arity</h4>

<p>lambda는 arity가 안 맞으면 에러. proc은 인자가 모자르면 nil을 넣고 남으면 무시함.</p>

<h4 id="return">return</h4>

<p>lambda에서 return 하면 method return과 동일하게 그 값을 반환.
Proc은 call된 스코프에서 return.</p>

<h3 id="method-objects">Method objects</h3>

<blockquote>
<p><em>Methods</em>: Bound to an object, they are evaluated in that object’s scope. They can also be unbound from their scope and rebound to another object or class.</p>
</blockquote>

<p>Method는 callable object다. 아래와 같이 메소드를 변수에 저장하고 call할 수 있다.</p>

<pre><code class="language-ruby">object = MyClass.new(1) m = object.method :my_method m.call # =&gt; 1
</code></pre>

<h4 id="method-proc-block-method">Method -&gt; Proc, Block -&gt; Method</h4>

<blockquote>
<p>you can convert a Method to a Proc by calling <code>Method#to_proc</code>, and you can convert a block to a method with <code>define_method</code>.</p>
</blockquote>

<h4 id="unbound-methods">Unbound Methods</h4>

<pre><code class="language-ruby">module MyModule
  def my_method
    42
  end
end

unbound = MyModule.instance_method(:my_method)
unbound.class # =&gt; UnboundMethod
</code></pre>

<p><a href="http://ruby-doc.org/core-2.5.3/UnboundMethod.html#￼method-i-bind">UnboundMethod#bind</a> 의 예시를 보자.
&gt; Bind <em>umeth</em> to <em>obj</em>. If Klass was the class from which <em>umeth</em> was obtained, obj.kind_of?(Klass) must be true.</p>

<pre><code class="language-ruby">class A
  def test
    puts “In test, class = #{self.class}&quot;
  end
end
class B &lt; A
end
class C &lt; B
end

um = B.instance_method(:test)
bm = um.bind(C.new)
bm.call # =&gt; In test, class = C
bm = um.bind(B.new)
bm.call # =&gt; In test, class = B
bm = um.bind(A.new)
bm.call # =&gt; prog.rb:16:in `bind’: bind argument must be an instance of B (TypeError) from prog.rb:16
</code></pre>

<h2 id="ch5-class-definitions">Ch5. Class Definitions</h2>

<h3 id="the-truth-about-class-methods">The truth About Class Methods</h3>

<blockquote>
<p><code>Klass.a_class_method</code> calls a method on an object (that also happens to be a class) referenced by a constant.</p>

<p>if you compare the definition of a Single- ton Method and the definition of a class method, you’ll see that they’re the same:</p>

<pre><code class="language-ruby">def obj.a_singleton_method;  end
def MyClass.another_class_method; end
</code></pre>
</blockquote>

<h3 id="class-macros">Class Macros</h3>

<pre><code class="language-ruby">class Book
  def self.deprecate(old_method, new_method)
    define_method(old_method) do |*args, &amp;block|
      warn &quot;Warning: #{old_method}() is deprecated. Use #{new_method}().&quot;
      send(new_method, *args, &amp;block)
    end
  end
  deprecate :GetTitle, :title
end
</code></pre>

<h3 id="singleton-classes">Singleton Classes</h3>

<p>Where does a singleton class belong?
&gt; an object can have its own special, hidden class. That’s called the *singleton class*of the object. (You can also hear it called the *metaclass*or the <em>eigenclass</em>. However, “singleton class” is the official name.)</p>

<pre><code class="language-ruby">obj = Object.new
singleton_class = class &lt;&lt; obj
  self
end
singleton_class.class # =&gt; Class

# Easier way
&quot;abc&quot;.singleton_class # =&gt; #&lt;Class:#&lt;String:0x331df0&gt;&gt;
</code></pre>

<blockquote>
<p>singleton classes have only a single instance (that’s where their name comes from), and they can’t be inherited. More important, <em>a singleton class is where an object’s Singleton Methods live</em>:</p>
</blockquote>

<p><code>instance_methods</code> 임에 주의!</p>

<pre><code class="language-ruby">def obj.my_singleton_method; end
singleton_class.instance_methods.grep(/my_/) # =&gt; [:my_singleton_method]
</code></pre>

<h3 id="method-lookup-revisited">Method Lookup Revisited</h3>

<p>아래 코드의 method lookup 과정을 다시 한 번 그려보자.</p>

<pre><code class="language-ruby">class C
  def self.a_class_method; end
  def a_method; end
end
class D &lt; C
end
obj = D.new
def obj.a_singleton_method; end
</code></pre>

<p><img src="https://user-images.githubusercontent.com/18223805/62420737-58294d80-b6d2-11e9-859f-f799d9d4d13c.png" alt="method_lookup" /></p>

<blockquote>
<p>The superclass of the singleton class of an object is the object’s class. The superclass of the singleton class of a class is the singleton class of the class’s superclass.
한국어로 정리하면 아래와 같다.
- 오브젝트의 싱글톤 클래스의 수퍼클래스는 오브젝트의 클래스
- 클래스의 싱글톤 클래스의 수퍼 클래스는 수퍼클래스의 싱글톤 클래스</p>

<p>When you call a method, Ruby goes “right” in the receiver’s real class and then “up” the ancestors chain.
오른쪽의 singleton class를 먼저 보고 그 다음 위의 수퍼 클래스로 올라간다.</p>
</blockquote>

<p>irb에서 출력해보면 singleton class 앞에는 <code>#</code> 가 붙는다.</p>

<pre><code class="language-ruby">irb(main):001:0&gt; &quot;abc&quot;.class
String &lt; Object
irb(main):002:0&gt; &quot;abc&quot;.singleton_class
#&lt;Class:#&lt;String:0x00007fc6e9130918&gt;&gt; &lt; String
</code></pre>

<h3 id="instance-eval의-진짜-의미">instance_eval의 진짜 의미</h3>

<blockquote>
<p>you learned that instance_eval changes self, and class_eval changes both self and the current class. However, instance_eval also changes the current class; it changes it to the *singleton class*of the receiver.</p>
</blockquote>

<h3 id="add-a-class-method-through-including-a-module">Add a class method through including a module</h3>

<pre><code class="language-ruby">module MyModule
  def my_method; 'hello'; end
end

class MyClass
  class &lt;&lt; self
    include MyModule
  end
end

puts MyClass.my_method
</code></pre>

<h3 id="object-extend-is-a-shortcut">Object#extend is a shortcut!</h3>

<p><code>Object#extend</code> 는 싱글톤 클래스에 모듈을 include한다.</p>

<h2 id="ch6-code-that-writes-code">Ch6. Code that writes code</h2>

<h3 id="kernel-eval">Kernel#eval</h3>

<p>문자열로 주어진 코드를 실행시킨다.</p>

<h3 id="binding-objects">Binding objects</h3>

<blockquote>
<p>A Binding is a whole scope packaged as an object. The idea is that you can create a Binding to capture the local scope and carry it around.</p>
</blockquote>

<p>책의 예시를 보자.</p>

<pre><code class="language-ruby">class MyClass
  def my_method
    @x = 1
    binding
  end
end
b = MyClass.new.my_method # binding을 얻음
eval &quot;@x&quot;, b # =&gt; 1
</code></pre>

<p><code>Kernel#binding</code> 문서의 예시를 보자.</p>

<pre><code class="language-ruby">def get_binding(param)
  binding
end
b = get_binding(&quot;hello&quot;)
eval(&quot;param&quot;, b)   #=&gt; &quot;hello&quot;
</code></pre>

<h4 id="irb">irb</h4>

<blockquote>
<p>irb is just a simple program that parses the standard input or a file and passes each line to eval.</p>
</blockquote>

<h4 id="object-taint">Object#taint</h4>

<blockquote>
<p>Objects that are marked as tainted will be restricted from various built-in methods. This is to prevent insecure data, such as command-line arguments or strings read from <code>Kernel#gets</code></p>
</blockquote>

<h3 id="hooks">Hooks</h3>

<p>상속, include, prepend, extend될 때 특정 코드를 실행시킨다.</p>

<pre><code class="language-ruby">class String
  def self.inherited(subclass)
    puts &quot;#{self} was inherited by #{subclass} &quot; end
  end
class MyString &lt; String; end
# String was inherited by MyString
</code></pre>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'hyunmin'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/hyunminyi">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/qpzm">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://qpzm.github.io/js/jquery-3.3.1.min.js"></script>
<script src="https://qpzm.github.io/js/main.js"></script>
<script src="https://qpzm.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
