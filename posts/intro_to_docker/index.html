<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		
		<meta name="generator" content="Hugo 0.55.4" />
		<title>도커(Docker), AWS Codebuild, CodePipeline을 활용한 레일즈(Ruby on Rails) 개발과 배포 &middot; Hyunmin Lee</title>
		<link rel="shortcut icon" href="https://qpzm.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://qpzm.github.io/css/style.css">
		<link rel="stylesheet" href="https://qpzm.github.io/css/highlight.css">

		
		<link rel="stylesheet" href="https://qpzm.github.io/css/font-awesome.min.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://qpzm.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://qpzm.github.io/posts'>Archive</a>
	<a href='https://qpzm.github.io/tags'>Tags</a>
	<a href='https://qpzm.github.io/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        도커(Docker), AWS Codebuild, CodePipeline을 활용한 레일즈(Ruby on Rails) 개발과 배포
                    </h1>
                    <h2 class="headline">
                    Mar 13, 2019 12:00
                    · 1087 words
                    · 6 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://qpzm.github.io/tags/docker">Docker</a>
                          
                              <a href="https://qpzm.github.io/tags/aws">AWS</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>도커에 대한 간략히 이해하고 레일즈 개발에 적용해 봅니다. 쓰다 보면 궁금해지므로 원리보다는 사용 방법에 집중합니다. 🙋 라벨이 붙은 내용은 넘어가도 좋습니다.</p>

<h2 id="1-굳이-왜">1. 굳이 왜?</h2>

<h3 id="쉽고-빠른-환경-설정">쉽고 빠른 환경 설정</h3>

<p>새 프로젝트를 시작하면 세팅하다 하루가 다 가곤 한다. 이제 Docker 를 이용하면 두 줄로 끝난다.</p>

<pre><code class="language-bash">docker-compose build
docker-compose up
</code></pre>

<h3 id="불변-배포-immutable-deployment">불변 배포 (Immutable deployment)</h3>

<p>과거의 나는 서버에 도대체 무슨 짓을 벌였는가?  <code>rvm</code>  <code>nginx</code> 등 온갖 패키지, 설정 파일의 향연에 좌절하곤 했다.</p>

<p>쉽게 똑같은 서버를 구성할 수 있다면 서버 관리, 롤백, Scaling에 유리하다.</p>

<h2 id="2-도커-맛보기">2. 도커 맛보기</h2>

<p>도커는 어플리케이션을 개발, 배포, 실행하기 위한 오픈소스 플랫폼입니다.</p>

<p><img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="Containers sharing same image" /></p>

<h3 id="이미지">이미지</h3>

<p>뜯기 전 3분 카레. Mysql docker image라면 mysql을 실행시킬 수 있게 코드, 의존성 패키지, 환경변수 등 모든 것이 준비되어 있다. Dockerfile을 빌드해서 만들며 여러 개의 레이어로 이뤄진다.</p>

<h3 id="컨테이너">컨테이너</h3>

<p>전자레인지에 돌린 3분 카레. 이미지를 실행시키면 컨테이너가 된다. Mysql 이미지의 컨테이너는 실제로 Mysql을 사용가능하다. 도커 이미지에 새 Read/Write layer를 올려서 만들어지고 종료 시 해당 레이어는 지워진다.</p>

<h3 id="기본-명령어">기본 명령어</h3>

<pre><code class="language-bash">docker run docker/whalesay cowsay &quot;난다 고래?&quot;
docker run -it docker/whalesay /bin/sh
docker ps # 실행중인 컨테이너 목록
docker ps -a # 모든 컨테이너 목록
docker stop &lt;container-id&gt;
docker rm &lt;container-id&gt; # 컨테이너 삭제
docker image ls # 이미지 목록
docker rmi &lt;image-id&gt; # 이미지 삭제
docker system prune # 안 쓰는 컨테이너, 이미지 모두 삭제
</code></pre>

<h3 id="레일즈-도커-파일-예시">레일즈 도커 파일 예시</h3>

<pre><code class="language-dockerfile">FROM ruby:2.5.3 # ubuntu with ruby 2.5.3

RUN apt-get update -qq &amp;&amp; \
    apt-get install -y build-essential libpq-dev nodejs imagemagick &amp;&amp; \
    rm -rf /var/lib/apt/lists/*

ENV RAILS_ROOT /var/www/app
RUN mkdir -p $RAILS_ROOT

WORKDIR $RAILS_ROOT

COPY Gemfile* ./
RUN gem install bundler -v '1.16.4' \
    &amp;&amp; bundler config --global frozen 1
RUN bundle install

VOLUME $RAILS_ROOT

EXPOSE 3000

CMD bundle exec rails db:migrate &amp;&amp; bundle exec puma -C config/puma.rb
</code></pre>

<h4 id="volume">VOLUME</h4>

<p>볼륨은 외부 저장 장치처럼 호스트의 저장공간을 쓰기 위해. DB 저장에 흔히 사용하는데 이유는 다음과 같다.</p>

<ul>
<li>컨테이너를 지워도 볼륨에 저장한 데이터는 남아있다.</li>
<li>볼륨에 기록하면 이미지 크기가 늘어나지 않는다.</li>
</ul>

<p>단 dockerfile에서 VOLUME 명령어는 mount point, 즉 빈 폴더만 만든다. <code>docker run -v &lt;host_path&gt;:&lt;container_path&gt;</code> 를 통해 실제로 마운트할 수 있다.</p>

<h4 id="expose">EXPOSE</h4>

<p>docker run 할 때 해당 포트를 사용하라는 표시.
실효는 없고 사용자에게 남기는 주석이다. (AWS 배포하는 플랫폼에 따라 이 표시를 활용하는 경우도 있다)</p>

<p><strong>Tip</strong></p>

<blockquote>
<p>In Docker 1.10 and higher, only <code>RUN</code>, <code>COPY</code>, and <code>ADD</code> instructions create layers. Other instructions create temporary intermediate images, and no longer directly increase the size of the build.</p>
</blockquote>

<p><a href="https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/#minimize-the-number-of-layers">https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/#minimize-the-number-of-layers</a></p>

<p><code>RUN</code>, <code>COPY</code>, <code>ADD</code> 세 명령어는 이미지 레이어를 만든다. 빌드할 때 아래 레이어가 변경된 경우, 그 위 레이어들을 전부 새로 빌드하므로 명령어 배치에 유의하자.</p>

<p>🙋🏼‍♀️Dockerfile부터 직접 이미지를 빌드해 보자: <a href="https://docs.docker.com/get-started/part2/">공식 튜토리얼</a></p>

<h3 id="정리">정리</h3>

<blockquote>
<p>컨테이너는 추상화된 어플리케이션이다.</p>
</blockquote>

<h4 id="추상화-abstraction">추상화 (Abstraction)</h4>

<p>중요한 것만 남기는 것. 3분 카레도 카레다.</p>

<ul>
<li>숫자: 1000원을 받으면 100원 짜리가 몇 개인지 신경쓰지 않는다.</li>
<li>OS의 하드웨어 추상화: 안드로이드 앱은 다양한 기기에서 실행된다.</li>
</ul>

<h4 id="vm-vs-container">VM vs Container</h4>

<p><img src="https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-and-vm-transparent-bg.png" alt="img" /></p>

<p><a href="https://www.docker.com/resources/what-container">도커 공식문서</a>에 따르면 컨테이너는 코드와 의존 패키지를 포함한 어플리케이션, 즉 OS 커널 위에서 실행되는 프로그램을 추상화한다. 반면, 가상머신은 컴퓨터 하드웨어를 추상화한다. 도커 컨테이너들은 OS 커널을 공유하기 때문에 더 적은 용량을 차지한다.</p>

<p><strong>잠깐!</strong></p>

<p>도커는 namespace(독립된 프로세스 공간), cgroup(리소스 제한) 등의 리눅스의 기능을 활용해서 만들어졌다. 따라서 Docker for mac은 리눅스를 돌리기 위한 가상머신을 추가로 설치한다.</p>

<h2 id="3-docker-compose">3. docker-compose</h2>

<p><code>docker-compose.yml</code> 파일을 정의하고 해당 파일이 있는 폴더에서 <code>docker-compose 명령어</code> 를 입력하면 여러 컨테이너를 한 번에 관리하고 옵션을 생략할 수 있어 편리하다.</p>

<h3 id="기본-명령어-1">⭐️ 기본 명령어</h3>

<h4 id="이미지-빌드-후-컨테이너-실행">이미지 빌드 후 컨테이너 실행</h4>

<ul>
<li>한 번도 빌드한 적이 없어 아직 이미지가 없을 때</li>
<li>Gemfile을 수정했을 때</li>
</ul>

<pre><code class="language-bash">docker-compose build
docker-compose up -d
docker-compose logs -f app
</code></pre>

<h4 id="터미널-명령어-입력">터미널 명령어 입력</h4>

<pre><code class="language-bash">$ docker-compose exec app bash
root@35b0e137ef35:/var/www/app# e.g. bundle exec rails db:migrate
</code></pre>

<h4 id="컨테이너-종료">컨테이너 종료</h4>

<pre><code>docker-compose down
</code></pre>

<p>🙋 <code>docker-compose</code>를 이용해 레일즈, postgresql을 실행해보자: <a href="https://docs.docker.com/compose/rails/">https://docs.docker.com/compose/rails/</a></p>

<h3 id="docker-compose-yml-구성">🙋 <code>docker-compose.yml</code> 구성</h3>

<p>예시 레일즈 프로젝트의  <code>/docker-compose.yml</code> 을 살펴보자.</p>

<pre><code class="language-yaml">version: '3.2' # use compose format v3
services:
  app:
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
      cache_from:
        - ${AWS_ECR_REPO}/rails:1.0.3
    image: ${AWS_ECR_REPO}/rails:1.0.3
    volumes:
      - ./:/var/www/app
      - ./config/database-docker.yml:/var/www/app/config/database.yml
    expose:
      - 3000
    environment:
      - RAILS_ENV=development
    depends_on:
      - db # 시작 순서를 조정, 단 해당 container의 started 상태만 보장, 내부적 준비 여부는 모름.

  db:
    image: mysql:5.7
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
    volumes:
      - ./db/development:/var/lib/mysql
    expose:
      - 3306
    environment:
      MYSQL_ROOT_PASSWORD: xxx
      MYSQL_DATABASE: xxx

  web:
    build:
      context: ./docker/web/
      cache_from:
        - ${AWS_ECR_REPO}/nginx:1.0.0
    image: ${AWS_ECR_REPO}/nginx:1.0.0
    ports:
      - 80:80
      - 4000:3000 # dev
    depends_on:
      - app
</code></pre>

<h2 id="4-staging-서버로-배포">4. Staging 서버로 배포</h2>

<h3 id="배포-과정">⭐️ 배포 과정</h3>

<ol>
<li><p><code>dev</code> 브랜치에서 <code>docker-compose.yml</code>과 <code>Dockerrun.aws.json</code> 의 레일즈 이미지 태그를 새 릴리즈 버전과 동일하게 업데이트 후 커밋</p></li>

<li><p><code>staging</code> 브랜치로 pull request &amp; squash and merge</p></li>

<li><p>AWS Codebuild 와 Codepipeline에 의해 ElasticBeanstalk에 자동 배포</p></li>
</ol>

<p><code>staging</code> 브랜치에 대한 푸시 권한을 제한하면 무분별한 배포를 막을 수 있다.</p>

<h3 id="codebuild">Codebuild</h3>

<p>도커 이미지를 빌드하고 이미지 저장소에 업로드</p>

<p>로컬에 AWS CLI가 설치되어 있다면 아래의 순서로 이미지 저장소에 푸시할 수 있다.</p>

<ol>
<li><code>aws configure</code> 명령어를 통해 해당 저장소에 업로드 권한이 있는 유저로 로그인</li>
<li>아래 build script의 <code>-</code> 다음에 나오는 명령어들을 순서대로 입력</li>
</ol>

<p><code>/buildspec.yml</code></p>

<pre><code class="language-yaml">version: 0.2 # build spec version

env:
  variables:
    AWS_DEFAULT_REGION: &quot;ap-northeast-2&quot;

phases:
  pre_build:
    commands:
      - echo Logging into Amazon ECR...
      - $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
      - echo Pulling Docker Images for cache...
      - docker-compose pull --ignore-pull-failures -q
  build:
    commands:
      - docker-compose build
  post_build:
    commands:
      - docker-compose push

artifacts:
  files:
    - './**/*'
</code></pre>

<h3 id="codepipeline">Codepipeline</h3>

<p>Github 소스코드를 Codebuild에 전달하고 ElasticBeanstalk에 배포</p>

<p><img src="https://user-images.githubusercontent.com/18223805/54255510-bc206d80-459b-11e9-983f-78aa42b95697.png" alt="image-20190313041603062" /></p>

<h3 id="aws-elasticbeanstalk-세부-내용">🙋🏼‍♀️ AWS ElasticBeanstalk 세부 내용</h3>

<p>AWS ElasticBeanstalk Multicontainer docker 환경을 사용한다. 이는 내부적으로 컨테이너 관리 서비스인 Elastic Container Service를 이용하며 <code>docker-compose.yml</code> 과 유사한 아래의 설정파일이 필요하다.</p>

<p><code>/Dockerrun.aws.json</code></p>

<pre><code class="language-json">{
  &quot;AWSEBDockerrunVersion&quot;: 2,
  &quot;containerDefinitions&quot;: [
    {
      &quot;environment&quot;: [
        {
          &quot;name&quot;: &quot;RAILS_ENV&quot;,
          &quot;value&quot;: &quot;production&quot;
        }
      ],
      &quot;essential&quot;: true,
      &quot;memory&quot;: 512,
      &quot;image&quot;: &quot;386640523397.dkr.ecr.ap-northeast-2.amazonaws.com/rails:1.0.3&quot;,
      &quot;mountPoints&quot;: [
        {
          &quot;containerPath&quot;: &quot;/var/www/app&quot;,
          &quot;sourceVolume&quot;: &quot;Performance_Plus_Rails&quot;
        },
        {
          &quot;containerPath&quot;: &quot;/var/www/app/config/database.yml&quot;,
          &quot;sourceVolume&quot;: &quot;Performance_Plus_Rails_DB_Config&quot;
        }
      ],
      &quot;name&quot;: &quot;app&quot;
    },
    {
      &quot;essential&quot;: true,
      &quot;memory&quot;: 512,
      &quot;image&quot;: &quot;386640523397.dkr.ecr.ap-northeast-2.amazonaws.com/nginx:1.0.0&quot;,
      &quot;mountPoints&quot;: [
        {
          &quot;containerPath&quot;: &quot;/var/www/app&quot;,
          &quot;sourceVolume&quot;: &quot;Performance_Plus_Rails&quot;
        }
      ],
      &quot;links&quot;: [
        &quot;app&quot;
      ],
      &quot;name&quot;: &quot;web&quot;,
      &quot;portMappings&quot;: [
        {
          &quot;containerPort&quot;: 80,
          &quot;hostPort&quot;: 80
        }
      ]
    }
  ],
  &quot;volumes&quot;: [
    {
      &quot;name&quot;: &quot;Performance_Plus_Rails&quot;,
      &quot;host&quot;: {
        &quot;sourcePath&quot;: &quot;/var/app/current/&quot; # elasticbeanstalk가 기본으로 파일을 업로드하는 위치
      }
    },
    {
      &quot;name&quot;: &quot;Performance_Plus_Rails_DB_Config&quot;,
      &quot;host&quot;: {
        &quot;sourcePath&quot;: &quot;/var/app/current/config/database-docker.yml&quot;
      }
    }
  ]
}
</code></pre>

<h4 id="links">links</h4>

<p>docker-compose는 자동으로 컨테이너 이름을 이용해 다른 컨테이너에 접속할 수 있게 도와준다.</p>

<p><code>/docker/web/nginx.conf</code> 의 일부</p>

<pre><code class="language-nginx">upstream rails_app {
  server app:3000; # app is defined in Dockerrun.aws.json &quot;link&quot;: [&quot;app&quot;]
}
</code></pre>

<p>추후 <a href="https://docs.docker.com/network/links/">deprecated 예정</a>이니 <code>network</code> 옵션으로 바꿀 계획. 자세한 옵션 설명은 <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html">Task Definition Parameters - Amazon Elastic Container Service</a> 을 참조하자.</p>

<h4 id="q-db-이미지는-어디로-갔나요">Q. db 이미지는 어디로 갔나요?</h4>

<p>DB는 rds로 운영하므로 필요없다!</p>

<h2 id="결론">결론</h2>

<p>⭐️ 만 익히고 쓰면서 찾아보자.</p>

<h2 id="reference">Reference</h2>

<p><strong>2. 도커 맛보기</strong></p>

<p>도커의 정의, 원리 <a href="https://docs.docker.com/engine/docker-overview/">https://docs.docker.com/engine/docker-overview/</a></p>

<p>Dockerfile부터 도커 허브에 푸시까지 <a href="https://docs.docker.com/get-started/part2/">Get Started, Part 2: Containers | Docker Documentation</a></p>

<p>Dockerfile 작성 시 유의사항 <a href="https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/">https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/</a></p>

<p>Layer 관점에서 본 이미지와 컨테이너 <a href="https://docs.docker.com/storage/storagedriver/">https://docs.docker.com/storage/storagedriver/</a></p>

<p>컨테이너는 어플리케이션의 추상화</p>

<ul>
<li><a href="https://www.docker.com/resources/what-container">What is a Container? | Docker</a></li>
<li><a href="https://blog.docker.com/2016/03/containers-are-not-vms/">Containers are not VMs - Docker Blog</a></li>
</ul>

<p>namespace와 cgroup <a href="https://tech.ssut.me/what-even-is-a-container/">https://tech.ssut.me/what-even-is-a-container/</a></p>

<p><strong>3. docker-compose</strong></p>

<ul>
<li><a href="https://docs.docker.com/compose/compose-file/">명령어 docs</a></li>
<li><a href="https://docs.docker.com/compose/rails/">docker-compose를 이용한 레일즈, postgresql 실행</a></li>
</ul>

<p><strong>4, Staging 서버로 배포</strong></p>

<p><a href="https://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html">AWS ElasticBeanstalk Multicontainer docker 환경 튜토리얼</a></p>

<p><code>Dockerrun.aws.json</code> 의 설정 옵션 <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html">Task Definition Parameters - Amazon Elastic Container Service</a></p>

<p>도커 전반에 대한 한글 자료 <a href="http://pyrasis.com/docker.html">http://pyrasis.com/docker.html</a></p>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'hyunmin'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/hyunminyi">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/qpzm">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://qpzm.github.io/js/jquery-3.3.1.min.js"></script>
<script src="https://qpzm.github.io/js/main.js"></script>
<script src="https://qpzm.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
